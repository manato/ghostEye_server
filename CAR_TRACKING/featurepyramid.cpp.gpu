///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////Car tracking project with laser_radar_data_fusion/////////////////////////////////////////
//////////////////////////////////////////////////////////////////////Copyright 2009-10 Akihiro Takeuchi///////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////featurepyramid.cpp   calculate HOG-feature pyramid ///////////////////////////////////////////////////////////

//OpenCV library
//#include "cv.h"			
//#include "cxcore.h"
//#include "highgui.h"	
#include "cv.h"
#include "highgui.h"
#include "cxcore.h"
#ifdef _DEBUG
//Debugモードの場合
#pragma comment(lib,"cv200d.lib") 
#pragma comment(lib,"cxcore200d.lib") 
#pragma comment(lib,"cvaux200d.lib") 
#pragma comment(lib,"highgui200d.lib") 
#else
//Releaseモードの場合
#pragma comment(lib,"cv200.lib") 
#pragma comment(lib,"cxcore200.lib") 
#pragma comment(lib,"cvaux200.lib") 
#pragma comment(lib,"highgui200.lib") 
#endif
//C++ library
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//#include <windows.h>
//#include <process.h>
#include <time.h>
#include <iostream>
using namespace std;

//Header files
#include "MODEL_info.h"		//File information
#include "Common.h"

#include "switch_float.h"

#ifndef WIN32
#define __stdcall void*
typedef void *HANDLE;
typedef long LONG_PTR;
#define INVALID_HANDLE_VALUE ((HANDLE)(LONG_PTR)-1)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//definition of constant
#define eps 0.0001

//definition of sin and cos
const FLOAT Hcos[9]={1.0000,0.9397,0.7660,0.5000,0.1736,-0.1736,-0.5000,-0.7660,-0.9397};
const FLOAT Hsin[9]={0.0000,0.3420,0.6428,0.8660,0.9848,0.9848,0.8660,0.6428,0.3420};

//definition of structure
struct thread_data {
  FLOAT *IM;
  int ISIZE[3];
  int FSIZE[2];
  int F_C;
  int sbin;
  FLOAT *Out;
};

//inline functions

static inline int max_i(int x,int y); //return maximum number (integer)
static inline int min_i(int x,int y); //return minimum number (integer)
static inline FLOAT min_2(FLOAT x);   //compare FLOAT with 0.2

//initialization functions 
FLOAT *ini_scales(Model_info *MI,IplImage *IM,int X,int Y); //initialize scales (extended to main)
int *ini_featsize(Model_info *MI); //initialize feature size information matrix (extended to main)

//subfunction
FLOAT *Ipl_to_FLOAT(IplImage *Input); //get intensity data (FLOAT) of input
void free_features(FLOAT **features,Model_info *MI); //release features
FLOAT *calc_feature(FLOAT *SRC,int *ISIZE,int *FTSIZE,int sbin); //calculate HOG features
void ini_thread_data(thread_data *TD,FLOAT *IM,int *INSIZE,int sbin,int level); //for thread-initialization
//unsigned __stdcall feat_calc(void *thread_arg);												//for thread_process													
void* feat_calc(void *thread_arg); //for thread_process													

//main function to calculate feature pyramid
FLOAT **calc_f_pyramid(IplImage *Image,Model_info *MI,int *FTSIZE,FLOAT *scale); //calculate feature pyramid (extended to detect.c)


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//external function

//resize.cpp
extern FLOAT *resize(FLOAT *src,int *sdims,int *odims,FLOAT scale); //resize image 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//inline functions 

//return maximum number (integer)
static inline int max_i(int x,int y) {return (x >= y ? x : y); }

//return minimum number (integer)
static inline int min_i(int x,int y) {return (x <= y ? x : y); }

//return minimum number (FLOAT)
static inline FLOAT min_2(FLOAT x) {return (x <= 0.2 ? x :0.2); }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* for use GPU */
#include <cuda.h>
#ifdef __cplusplus
extern "C"
#endif
char *conv(unsigned int res);
extern CUfunction func_calc_feature;
extern int NR_MAXTHREADS_X, NR_MAXTHREADS_Y;
extern CUdevice dev;
CUdeviceptr IM_dev, ISIZE_dev;




//initialization functions

//initialize scales
FLOAT *ini_scales(Model_info *MI,IplImage *IM,int X,int Y) //X,Y length of image 
{
  
  int interval,max_scale;
  
  if(MI->ini)
    {
      //calculate max scale
      //MI->interval/=2;	//reduce calculation time
      const int sbin = MI->sbin;
      interval = MI->interval;
      const FLOAT sc = pow(2.0,(1/(double)interval));//縮小比を表している。
      const FLOAT minsize = FLOAT(min_i(X,Y));
      const int numcomponent = MI->numcomponent;
      //max_scale = 1+int(floor(log(minsize/(5*FLOAT(sbin)))/log(sc)));
      max_scale = 36;
      const int L_NUM = interval+max_scale;
      
      FLOAT MRY =(FLOAT)MI->rsize[0];
      FLOAT MRX =(FLOAT)MI->rsize[1];
		   
      for(int kk=1;kk<numcomponent;kk++)
        {
          if(MI->rsize[kk*2]<MRY) MRY=MI->rsize[kk*2];
          if(MI->rsize[kk*2+1]<MRX) MRX=MI->rsize[kk*2+1];
        }
      
      MRY/=2;
      MRX/=2;
      
      FLOAT height =(FLOAT)IM->height/(FLOAT)sbin;
      FLOAT width = (FLOAT)IM->width/(FLOAT)sbin;
      FLOAT sc_step =1/sc;   //縮小率
      
      for(int kk=0;kk<L_NUM;kk++)
        {
          height*=sc_step;
          width*=sc_step;
          if(height<MRY || width<MRX)
            {
              max_scale = kk-interval-1;
              break;
            }
        }
      
      if(max_scale<interval) max_scale = interval;
      MI->max_scale=max_scale;
      printf("max_scale:%d\n",max_scale);
      MI->IM_HEIGHT=IM->height;
      /*printf("高さ%d\n",MI->IM_HEIGHT);*/
      MI->IM_WIDTH=IM->width;
      /*printf("横%d\n",MI->IM_WIDTH);*/
      MI->ini=false;
    }
  else
    {
      interval = MI->interval;
      max_scale = MI->max_scale;
    }
  
  //return
  FLOAT *scales = (FLOAT*)calloc((max_scale+interval),sizeof(FLOAT));		//Model information
  return(scales);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//initialize feature size matrix

int *ini_featsize(Model_info *MI)
{
  const int LofFeat=MI->max_scale+MI->interval;
  int *featsize = (int*)calloc(LofFeat*2,sizeof(FLOAT)); // feature size information matrix
  return(featsize);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//calculate HOG features from Image
//HOG features are calculated for each block(BSL*BSL pixels)
FLOAT *calc_feature(FLOAT *SRC,int *ISIZE,int *FTSIZE,int sbin)
{
  CUresult res;

  struct timeval tv;
  struct timeval tv_calc_feature_all_start, tv_calc_feature_all_end;
  float time_all=0;
  struct timeval tv_loop1_start, tv_loop1_end;
  float time_loop1=0;
  struct timeval tv_loop2_start, tv_loop2_end;
  float time_loop2=0;
  struct timeval tv_loop3_start, tv_loop3_end;
  float time_loop3=0;

  gettimeofday(&tv_calc_feature_all_start, NULL);

  //input size 
  const int height=ISIZE[0]; //{268,268,134,67,233,117,203,203,177,154,89,203,154,77}
  const int width=ISIZE[1];  //{448,112,224,390,195,340,170,296,257,148,340,257,129}
  const int dims[2]={height,width};

  //size of Histgrams and Norm calculation space size 
  const int blocks[2] = {(int)floor(double(height)/double(sbin)+0.5),(int)floor(double(width)/double(sbin)+0.5)};//{67,112}....sbine=4
  const int BLOCK_SQ = blocks[0]*blocks[1];//{7504}...
  const int BX = blocks[0]+1;//68...

  //Output features size(Output)
  const int OUT_SIZE[3]={max_i(blocks[0]-2,0),max_i(blocks[1]-2,0),27+4};//{65,110,31}.....
  const int O_DIM=OUT_SIZE[0]*OUT_SIZE[1];//{7150}.....
  const int DIM_N =9*BLOCK_SQ;//{67536}

  //Visible range (eliminate border blocks)
  const int visible[2]={blocks[0]*sbin,blocks[1]*sbin};
  const int vis_R[2] ={visible[0]-1,visible[1]-1};
  const int vp0=dims[0]-2;
  const int vp1=dims[1]-2;
  const int SQUARE =dims[0]*dims[1];
  const FLOAT SBIN = FLOAT(sbin);
	

  //HOG Histgram and Norm
  //  FLOAT *HHist = (FLOAT*)calloc(BLOCK_SQ*18,sizeof(FLOAT)); // HOG histgram
  FLOAT *HHist;
  res = cuMemHostAlloc((void**)&HHist, BLOCK_SQ*18*sizeof(FLOAT), CU_MEMHOSTALLOC_DEVICEMAP);
  if(res != CUDA_SUCCESS) {
    printf("cuMemHostAlloc(HHist) failed: res = %s\n", conv(res));
    exit(1);
  }
  memset(HHist, 0, BLOCK_SQ*18*sizeof(FLOAT));  //zero clear

  FLOAT *Norm = (FLOAT*)calloc(BLOCK_SQ,sizeof(FLOAT));     // Norm

  //feature(Output)
  FLOAT *feat=(FLOAT*)calloc(OUT_SIZE[0]*OUT_SIZE[1]*OUT_SIZE[2],sizeof(FLOAT));

#if 1
  CUdeviceptr HHist_dev;
  res = cuMemAlloc(&HHist_dev, BLOCK_SQ*18*sizeof(FLOAT));
  if(res != CUDA_SUCCESS) {
    printf("cuMemAlloc(HHist_dev) failed: res = %s\n", conv(res));
    exit(1);
  }


  gettimeofday(&tv_memcpy_start, NULL);
  res = cuMemcpyHtoD(HHist_dev, HHist, BLOCK_SQ*18*sizeof(FLOAT));
  if(res != CUDA_SUCCESS) {
    printf("cuMemcpyHtoD(HHist) failed: res = %s\n", conv(res));
    exit(1);
  }
  gettimeofday(&tv_memcpy_end, NULL);
  tvsub(&tv_memcpy_end, &tv_memcpy_start, &tv);
  time_memcpy += tv.tv_sec * 1000.0 + (float)tv.tv_usec / 1000.0;

  int sharedMemBytes = 0;

  /* define CUDA block shape */
  int max_threads_num = 0; 
  int thread_num_x, thread_num_y;
  int block_num_x, block_num_y;

  res = cuDeviceGetAttribute(&max_threads_num, CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK, dev);
  if(res != CUDA_SUCCESS){
    printf("\ncuDeviceGetAttribute() failed: res = %s\n", conv(res));
    exit(1);
  }
  
  // NR_MAXTHREADS_X = (int)sqrt((double)max_threads_num);
  // NR_MAXTHREADS_Y = (int)sqrt((double)max_threads_num);

  NR_MAXTHREADS_X = 8;
  NR_MAXTHREADS_Y = 8;
  //  printf("vis_R[1] %3d vis_R[0] %3d\n", vis_R[1], vis_R[0]);
  
  thread_num_x = (vis_R[1] < NR_MAXTHREADS_X) ? vis_R[1] : NR_MAXTHREADS_X;
  thread_num_y = (vis_R[0] < NR_MAXTHREADS_Y) ? vis_R[0] : NR_MAXTHREADS_Y;
  
  block_num_x = vis_R[1] / thread_num_x;
  block_num_y = vis_R[0] / thread_num_y;
  if(vis_R[1] % thread_num_x != 0) block_num_x++;
  if(vis_R[0] % thread_num_y != 0) block_num_y++;

  void* kernel_args[] = {
    &IM_dev,                    // FLOAT *SRC
    &ISIZE_dev,                 // int *ISIZE
    &HHist_dev,                 // FLOAT *HHist
    (void*)&vis_R[1],           // int vis_R1
    (void*)&vis_R[0],           // int vis_R0
    (void*)&sbin                // int sbin
  };


  //calculate HOG histgram
  gettimeofday(&tv_loop1_start, NULL);

  gettimeofday(&tv_kernel_start, NULL);
  /* launch GPU kernel */
  res = cuLaunchKernel(
                       func_calc_feature, // call function
                       block_num_x,       // gridDimX
                       block_num_y,       // gridDimY
                       1,                 // gridDimZ
                       thread_num_x,      // blockDimX
                       thread_num_y,      // blockDimY
                       1,                 // blockDimZ
                       sharedMemBytes,    // sharedMemBytes
                       NULL,              // hStream
                       kernel_args,       // kernelParams
                       NULL               // extra
                       );
  if(res != CUDA_SUCCESS) { 
    printf("cuLaunchKernel(calc_feature) failed : res = %s\n", conv(res));
    exit(1);
  }

  res = cuCtxSynchronize();
  if(res != CUDA_SUCCESS) {
    printf("cuCtxSynchronize(calc_feature) failed: res = %s\n", conv(res));
    exit(1);
  }

  gettimeofday(&tv_kernel_end, NULL);
  tvsub(&tv_kernel_end, &tv_kernel_start, &tv);
  time_kernel += tv.tv_sec * 1000.0 + (float)tv.tv_usec / 1000.0;

  gettimeofday(&tv_memcpy_start, NULL);
  /* download data from GPU */
  res = cuMemcpyDtoH(HHist, HHist_dev, BLOCK_SQ*18*sizeof(FLOAT));
  if(res != CUDA_SUCCESS) {
    printf("cuMemcpyDtoH(HHist) failed: res = %s\n", conv(res));
    exit(1);
  }
  gettimeofday(&tv_memcpy_end, NULL);
  tvsub(&tv_memcpy_end, &tv_memcpy_start, &tv);
  time_memcpy += tv.tv_sec * 1000.0 + (float)tv.tv_usec / 1000.0;

  // FILE *tmpfp=fopen("tmp.dat", "w");
  // for(int i=0; i<BLOCK_SQ*18; i++) {
  //   fprintf(tmpfp, "%f\n", HHist[i]);
  // }
  // fclose(tmpfp);

#else
  
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  // most time consumning
  for(int x=1;x<vis_R[1];x++)
    {
      //parameters for interpolation
      FLOAT xp=((FLOAT)x+0.5)/SBIN-0.5;
      int ixp=(int)floor(xp);
      int ixpp=ixp+1;
      int ixp_b  = ixp * blocks[0];	
      int ixpp_b = ixp_b + blocks[0];
      FLOAT vx0=xp-(FLOAT)ixp;	
      FLOAT vx1=1.0-vx0;
      bool flag1=true,flag2=true,flagX=true;

      if(ixp<0) 
        {
          flag1=false;
          flagX=false;
        }
      if(ixpp>=blocks[1])
        {
          flag2=false;
          flagX=false;
        }

      int YC=min_i(x,vp1)*dims[0];
      FLOAT *SRC_YC = SRC+YC;

      for(int y=1;y<vis_R[0];y++)
        {
          //first color channel
          FLOAT *s=SRC_YC+min_i(y,vp0);
          FLOAT dy=*(s+1)-*(s-1);
          FLOAT dx=*(s+dims[0])-*(s-dims[0]);
          FLOAT v=dx*dx+dy*dy;
          
          //second color channel
          s+=SQUARE;
          FLOAT dy2=*(s+1)-*(s-1);
          FLOAT dx2=*(s+dims[0])-*(s-dims[0]);
          FLOAT v2=dx2*dx2+dy2*dy2;
          
          //third color channel
          s+=SQUARE;
          FLOAT dy3=*(s+1)-*(s-1);
          FLOAT dx3=*(s+dims[0])-*(s-dims[0]);
          FLOAT v3=dx3*dx3+dy3*dy3;
          
          //pick channel with strongest gradient
          if(v2>v)
            {
              v=v2;
              dx=dx2;
              dy=dy2;
            }

          if(v3>v)
            {
              v=v3;
              dx=dx3;
              dy=dy3;
            }

          FLOAT best_dot=0.0;
          int best_o=0;
			
          //snap to one of 18 orientations
          for(int o=0;o<9;o++)
            {
              FLOAT dot=Hcos[o]*dx+Hsin[o]*dy;
              if(dot>best_dot)
                {
                  best_dot=dot;
                  best_o=o;
                }
              else if(-dot>best_dot)
                {
                  best_dot=-dot;
                  best_o=o+9;
                }
            }

          //Add to 4 histgrams around pixel using linear interpolation
          FLOAT yp=((FLOAT)y+0.5)/SBIN-0.5;
          int iyp=(int)floor(yp);
          int iypp=iyp+1;
          FLOAT vy0=yp-(FLOAT)iyp;
          FLOAT vy1=1.0-vy0;
          v=sqrt(v);
          int ODim=best_o*BLOCK_SQ;
          FLOAT *Htemp = HHist+ODim;
          FLOAT vx1Xv =vx1*v;
          FLOAT vx0Xv = vx0*v;



          if(flagX)
            {
              if(iyp>=0)
                {
                  *(Htemp+ ixp_b+iyp)+=vy1*vx1Xv; //1-少数をxyでかけたものにエッジ強度の2乗をかけたもの
                  *(Htemp+ ixpp_b+iyp)+=vy1*vx0Xv;
                }
              if (iypp<blocks[0])
                {
                  *(Htemp+ ixp_b+iypp)+=vy0*vx1Xv;
                  *(Htemp+ ixpp_b+iypp)+=vy0*vx0Xv;
                }
            }
          else if(flag1)
            {
              if (iyp>=0) {
                *(Htemp+ixp_b+iyp)+=vy1*vx1Xv;
              }
              if (iypp<blocks[0]) {
                *(Htemp+ixp_b+iypp)+=vy0*vx1Xv;
              }
            }
          else if(flag2)
            {
              if(iyp>=0) {
                *(Htemp+ixpp_b+iyp)+=vy1*vx0Xv;
              }
              if(iypp<blocks[0]) {
                *(Htemp+ixpp_b+iypp)+=vy0*vx0Xv;
              }
            }
        }
    }
  // FILE *tmpfp=fopen("tmp.dat", "w");
  // for(int i=0; i<BLOCK_SQ*18; i++) {
  //   fprintf(tmpfp, "%f\n", HHist[i]);
  // }
  // fclose(tmpfp);


#endif
  
  gettimeofday(&tv_loop1_end, NULL);
  tvsub(&tv_loop1_end, &tv_loop1_start, &tv);
  time_loop1 += tv.tv_sec*1000.0 + tv.tv_usec/1000.0;


  //compute energy in each block by summing over orientations
  gettimeofday(&tv_loop2_start, NULL);
  for(int kk=0;kk<9;kk++)
    {
      FLOAT *src1=HHist+kk*BLOCK_SQ;
      FLOAT *src2=src1+DIM_N;
      FLOAT *dst=Norm;
      FLOAT *end=Norm+BLOCK_SQ;
      while(dst<end)
        {
          FLOAT sss=*src1+*src2;
          *(dst++)+=sss*sss;
          src1++;src2++;
        }
    }
  gettimeofday(&tv_loop2_end, NULL);
  tvsub(&tv_loop2_end, &tv_loop2_start, &tv);
  time_loop2 += tv.tv_sec*1000.0 + tv.tv_usec/1000.0;

  //compute features
  gettimeofday(&tv_loop3_start, NULL);
  for(int x=0;x<OUT_SIZE[1];x++)
    {
      FLOAT *dst_X = feat+x*OUT_SIZE[0];
      int BB = x*blocks[0];		
      int BA = BB+blocks[0];
      
      FLOAT *pt = Norm+BA;
      FLOAT nc1 = 1.0/sqrt(*pt+*(pt+1)+*(pt+blocks[0])+*(pt+BX)+eps);
      pt = Norm+BB;
      FLOAT nc3 = 1.0/sqrt(*pt+*(pt+1)+*(pt+blocks[0])+*(pt+BX)+eps);

      for(int y=0;y<OUT_SIZE[0];y++)
        {
          FLOAT *dst=dst_X+y;
          FLOAT *src,*p,n1,n2,n3,n4;
          //calculate normarize factor
          int yp = y+1;

          p=Norm+BA+yp;
          n1 = 1.0/sqrt(*p+*(p+1)+*(p+blocks[0])+*(p+BX)+eps);
          n2 = nc1;
          nc1 = n1;

          p=Norm+BB+yp;
          n3 = 1.0/sqrt(*p+*(p+1)+*(p+blocks[0])+*(p+BX)+eps);
          n4 = nc3;
          nc3 = n3;

          //features for each orientations
          FLOAT t1=0,t2=0,t3=0,t4=0;

          //contrast-sensitive features(18)
          src=HHist+BA+yp;
          for(int kk=0;kk<18;kk++)
            {
              FLOAT h1=min_2(*src*n1);
              FLOAT h2=min_2(*src*n2);
              FLOAT h3=min_2(*src*n3);
              FLOAT h4=min_2(*src*n4);
              *dst=0.5*(h1+h2+h3+h4);
              t1+=h1;
              t2+=h2;
              t3+=h3;
              t4+=h4;
              dst+=O_DIM;
              src+=BLOCK_SQ;
            }

          //contrast-insensitive features(9)
          src=HHist+BA+yp;
          for(int kk=0;kk<9;kk++)
            {
              FLOAT sum = *src+*(src+DIM_N);
              FLOAT h1=min_2(sum*n1);
              FLOAT h2=min_2(sum*n2);
              FLOAT h3=min_2(sum*n3);
              FLOAT h4=min_2(sum*n4);
              *dst=0.5*(h1+h2+h3+h4);
              dst+=O_DIM;
              src+=BLOCK_SQ;
            }

          //texture gradient
          *dst=0.2357*t1;
          dst+=O_DIM;
          *dst=0.2357*t2;
          dst+=O_DIM;
          *dst=0.2357*t3;
          dst+=O_DIM;
          *dst=0.2357*t4;
        }
    }
  gettimeofday(&tv_loop3_end, NULL);
  tvsub(&tv_loop3_end, &tv_loop3_start, &tv);
  time_loop3 += tv.tv_sec*1000.0 + tv.tv_usec/1000.0;


  //Release
  //  s_free(HHist);
  res = cuMemFreeHost(HHist);
  if(res != CUDA_SUCCESS) {
    printf("cuMemFreeHost(HHist) failed: res = %s\n", conv(res));
    exit(1);
  }

#if 1
  res = cuMemFree(HHist_dev);
  if(res != CUDA_SUCCESS) {
    printf("cuMemFree(HHist_dev) failed: res = %s\n", conv(res));
    exit(1);
  }
#endif
  s_free(Norm);
	
  //size of feature(output)
  *FTSIZE=OUT_SIZE[0];
  *(FTSIZE+1)=OUT_SIZE[1];
  //	printf("feat%f\n",*(feat));
  gettimeofday(&tv_calc_feature_all_end, NULL);
  tvsub(&tv_calc_feature_all_end, &tv_calc_feature_all_start, &tv);
  time_all += tv.tv_sec*1000.0 + tv.tv_usec/1000.0;


#if 0
  printf("\n");
  printf("calc_feature all %f\n", time_all);
  printf("loop1            %f\n", time_loop1);
  printf("loop2            %f\n", time_loop2);
  printf("loop3            %f\n", time_loop3);
#endif
  return(feat);

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//sub functions

// get pixel-intensity(FLOAT)  of image(IplImage)

FLOAT *Ipl_to_FLOAT(IplImage *Input)	//get intensity data (FLOAT) of input
{
  const int width = Input->width;
  printf("%d\n",width);
  const int height = Input->height;
  printf("%d\n",height);
  const int nChannels = Input->nChannels;
  printf("%d\n",nChannels);
  const int SQ = height*width;
  const int WS = Input->widthStep;

  FLOAT *Output = (FLOAT *)malloc(sizeof(FLOAT)*height*width*nChannels);
  printf("%d",height*width*nChannels);

  FLOAT *R= Output;
  FLOAT *G= Output+SQ;
  FLOAT *B= Output+2*SQ;
  char *IDATA = Input->imageData;

  //pick intensity of pixel (color)
  for(int x=0;x<width;x++)
    {
      int XT = x*3;
      for(int y=0;y<height;y++)
        {
          int pp = WS*y+XT;
          *(B++)=(FLOAT)(unsigned char)IDATA[pp];	//B
          pp++;
          *(G++)=(FLOAT)(unsigned char)IDATA[pp];	//G

          pp++;
          *(R++)=(FLOAT)(unsigned char)IDATA[pp];	//R
        }
    }
  return(Output);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// feature calculation
//unsigned __stdcall feat_calc(void *thread_arg) 
//void* feat_calc(void *thread_arg) 
//void feat_calc(thread_data *thread_arg) 
void feat_calc(thread_data *thread_arg) // called total 42times per 1picture
{
  thread_data *args = (thread_data *)thread_arg;
  FLOAT *IM = args->IM;         // malloc(RISIZE[0]*RISIZE[1]*RISIZE[2]*sizeof(FLOAT))
  int *ISIZE = args->ISIZE;     // int ISIZE[3]
  int *FSIZE = args->FSIZE;     // int FSIZE[3]
  int sbin = args->sbin;
  FLOAT *Out =calc_feature(args->IM,args->ISIZE,args->FSIZE,args->sbin);			
  args->Out =Out;			
  //_endthreadex(0);
  //return(0);
  //  pthread_exit((void*)thread_arg);
  return;
}

void feat_calc_GPU(thread_data *thread_arg, int RISIZE[3]) // called total 42times per 1picture
{
  struct timeval tv;
  CUresult res;

  thread_data *args = (thread_data *)thread_arg;
  FLOAT *IM = args->IM;         // malloc(RISIZE[0]*RISIZE[1]*RISIZE[2]*sizeof(FLOAT))
  int *ISIZE = args->ISIZE;     // int ISIZE[3]
  int *FSIZE = args->FSIZE;     // int FSIZE[2]
  int sbin = args->sbin;

  int IM_size = RISIZE[0]*RISIZE[1]*RISIZE[2]*sizeof(FLOAT);


  /* allocate GPU memory */
  res = cuMemAlloc(&IM_dev, IM_size);
  if(res != CUDA_SUCCESS) {
    printf("cuMemAlloc(IM_dev) failed: res = %s\n", conv(res));
    exit(1);
  }

  res = cuMemAlloc(&ISIZE_dev, 3*sizeof(int));
  if(res != CUDA_SUCCESS) {
    printf("cuMemAlloc(ISIZE_dev) failed: res = %s\n", conv(res));
    exit(1);
  }


  gettimeofday(&tv_memcpy_start, NULL);
  /* upload data to GPU */
  res = cuMemcpyHtoD(IM_dev, &IM[0], IM_size);
  if(res != CUDA_SUCCESS) {
    printf("cuMemcpyHtoD(IM) failed: res = %s\n", conv(res));
    exit(1);
  }

  res = cuMemcpyHtoD(ISIZE_dev, ISIZE, 3*sizeof(int));
  if(res != CUDA_SUCCESS) {
    printf("cuMemcpyHtoD(ISIZE) failed: res = %s\n", conv(res));
    exit(1);
  }
  gettimeofday(&tv_memcpy_end, NULL);
  tvsub(&tv_memcpy_end, &tv_memcpy_start, &tv);
  time_memcpy += tv.tv_sec * 1000.0 + (float)tv.tv_usec / 1000.0;


  FLOAT *Out =calc_feature(args->IM,args->ISIZE,args->FSIZE,args->sbin);			
  args->Out =Out;			

  /* free GPU memory */
  res = cuMemFree(IM_dev);
  if(res != CUDA_SUCCESS) {
    printf("cuMemFree(IM_dev) failed: res = %s\n", conv(res));
    exit(1);
  }

  res = cuMemFree(ISIZE_dev);
  if(res != CUDA_SUCCESS) {
    printf("cuMemFree(ISIZE_dev) failed: res = %s\n", conv(res));
    exit(1);
  }

  return;
}

//void initialize thread data
void ini_thread_data(thread_data *TD,FLOAT *IM,int *INSIZE,int sbin,int level)
{
  
  TD->IM=IM; 
  //memcpy_s(TD->ISIZE,sizeof(int)*3,INSIZE,sizeof(int)*3);
  memcpy(TD->ISIZE, INSIZE,sizeof(int)*3);
  TD->FSIZE[0]=0;
  TD->FSIZE[1]=0;
  TD->sbin=sbin;
  TD->F_C=level;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//calculate feature pyramid (extended to main.cpp)

//calculate feature pyramid
FLOAT **calc_f_pyramid(IplImage *Image,Model_info *MI,int *FTSIZE,FLOAT *scale)	//calculate feature pyramid
{

  struct timeval tv;
  struct timeval tv_calc_f_pyramid_start, tv_calc_f_pyramid_end;
  struct timeval tv_loop1_start, tv_loop1_end;
  float time_loop1=0;
  struct timeval tv_loop2_start, tv_loop2_end;
  float time_loop2=0;
  struct timeval tv_loop3_start, tv_loop3_end;
  float time_loop3=0;
  struct timeval tv_loop4_start, tv_loop4_end;
  float time_loop4=0;
  struct timeval tv_loop5_start, tv_loop5_end;
  float time_loop5=0;
  gettimeofday(&tv_calc_f_pyramid_start, NULL);

  //constant parameters 
  const int max_scale = MI->max_scale;
  const int interval = MI->interval;
  const int sbin = MI->sbin;
  const int sbin2 = (int)floor((double)sbin/2.0);
  const int LEN = max_scale+interval;
  const FLOAT sc = pow(2,(1.0/(double)interval));
  int INSIZE[3]={Image->height,Image->width,Image->nChannels};
  int RISIZE[3]={0,0,0},OUTSIZE[3] ={0,0,0};
  
  //Original image (FLOAT)
  FLOAT *D_I = Ipl_to_FLOAT(Image);
  
  //features
  FLOAT **feat=(FLOAT**)malloc(sizeof(FLOAT*)*LEN); //Model information
  
  //thread for feature calculation
  unsigned threadID;
  thread_data *td = (thread_data *)calloc(LEN, sizeof(thread_data));	
  
  FLOAT **RIM_S =(FLOAT**)calloc(LEN,sizeof(FLOAT*));	
  
  int *RI_S = (int*)calloc(interval*3,sizeof(int));
  FLOAT *RIM_T;
  int t_count=0;
  
  //calculate resized image 
  gettimeofday(&tv_loop3_start, NULL);
  for(int ii=0;ii<interval;ii++) 
    {
      FLOAT st = 1.0/pow(sc,ii);
      RIM_S[ii] = resize(D_I,INSIZE,RISIZE,st); // RIMS_S=calloc(RISIZE[0]*[1]*[2]*sizeof(FLOAT))
      memcpy(RI_S+ii*3, RISIZE,sizeof(int)*3);
    }
  gettimeofday(&tv_loop3_end, NULL);
  tvsub(&tv_loop3_end, &tv_loop3_start, &tv);
  time_loop3 += tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0;

  
  gettimeofday(&tv_loop1_start, NULL);


  for(int ii=0;ii<interval;ii++) // interval==10
    {
      FLOAT st = 1.0/pow(sc,ii);
      memcpy(RISIZE, RI_S+ii*3,sizeof(int)*3);
      
      //"first" 2x interval

      ini_thread_data(&td[t_count],RIM_S[ii],RISIZE,sbin2,ii);  //initialize thread

      gettimeofday(&tv_loop4_start, NULL);
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // time consumer
      //      feat_calc(&td[t_count]);
      feat_calc_GPU(&td[t_count], RISIZE);
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      gettimeofday(&tv_loop4_end, NULL);
      tvsub(&tv_loop4_end, &tv_loop4_start, &tv);
      time_loop4 += tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0;


      *(scale+ii)=st*2;         //save scale
      t_count++;
      
      //"second" 1x interval
      RIM_S[ii+interval]=RIM_S[ii];
      

      ini_thread_data(&td[t_count],RIM_S[ii+interval],RISIZE,sbin,ii+interval); //initialize thread

      gettimeofday(&tv_loop5_start, NULL);
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      // time consumer
      //      feat_calc(&td[t_count]);
      feat_calc_GPU(&td[t_count], RISIZE);
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      gettimeofday(&tv_loop5_end, NULL);
      tvsub(&tv_loop5_end, &tv_loop5_start, &tv);
      time_loop5 += tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0;


      *(scale+ii+interval)=st;  //save scale
      t_count++;
      
      //remained resolutions (for root_only)
      RIM_T = RIM_S[ii];        //get original image (just a copy)

      gettimeofday(&tv_loop2_start, NULL);
      for(int jj=ii+interval;jj<max_scale;jj+=interval)
        {
          RIM_S[jj+interval] = resize(RIM_T,RISIZE,OUTSIZE,0.5); //resize image (FLOAT)
          memcpy(RISIZE, OUTSIZE,sizeof(int)*3);
          ini_thread_data(&td[t_count],RIM_S[jj+interval],RISIZE,sbin,jj+interval); //initialize thread

          //          feat_calc(&td[t_count]);
          feat_calc_GPU(&td[t_count], RISIZE);

          *(scale+jj+interval)=0.5*(*(scale+jj)); //save scale
          RIM_T = RIM_S[jj+interval];
          t_count++;
        }
      gettimeofday(&tv_loop2_end, NULL);
      tvsub(&tv_loop2_end, &tv_loop2_start, &tv);
      time_loop2 += tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0;
      

    }
  gettimeofday(&tv_loop1_end, NULL);
  tvsub(&tv_loop1_end, &tv_loop1_start, &tv);
  time_loop1 += tv.tv_sec * 1000.0 + tv.tv_usec / 1000.0;

  
  //get thread data
  for(int ss=0;ss<LEN;ss++)
    {
      feat[td[ss].F_C]=td[ss].Out;
      memcpy(&FTSIZE[td[ss].F_C*2], td[ss].FSIZE,sizeof(int)*2);
    }
  
  //release original image 
  s_free(D_I);
  
  //release resized image 
  for(int ss=0;ss<interval;ss++) s_free(RIM_S[ss]);
  for(int ss=interval*2;ss<LEN;ss++) s_free(RIM_S[ss]);
  s_free(RI_S);
  s_free(RIM_S);
  
  
  //release thread information
  s_free(td);		

  // printf("\n===================================\n");
  // printf("-- printed by featurepyramid.cpp --\n");
  // gettimeofday(&tv_calc_f_pyramid_end, NULL);
  // tvsub(&tv_calc_f_pyramid_end, &tv_calc_f_pyramid_start, &tv);
  // printf("calc_f_pyramid all %f\n", tv.tv_sec*1000.0 + tv.tv_usec/1000.0);
  // printf("loop 1 %f\n", time_loop1);  
  // printf("inner loop 2 %f\n", time_loop2);  
  // printf("loop 3 %f\n", time_loop3);  
  // printf("inner loop 4 %f\n", time_loop4);  
  // printf("inner loop 5 %f\n", time_loop5);  
  // printf("===================================\n");

  printf("\n");

  return(feat);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//release function
//release feature pyramid

void free_features(FLOAT **features,Model_info *MI)
{
  int LofFeat=MI->max_scale+MI->interval;
  if(features!=NULL)
    {
      for (int ii=0;ii<LofFeat;ii++)
        {
          s_free(features[ii]);
        }
      s_free(features);
    }
}

FLOAT *calc_feature1(FLOAT *SRC,int *ISIZE,int *FTSIZE,int sbin)
{
  
  //input size 
  const int height=ISIZE[0];
  const int width=ISIZE[1];
  const int dims[2]={height,width};
  
  //size of Histgrams and Norm calculation space size 
  const int blocks[2] = {(int)floor(double(height)/double(sbin)+0.5),(int)floor(double(width)/double(sbin)+0.5)};
  const int BLOCK_SQ = blocks[0]*blocks[1];
  const int BX = blocks[0]+1;
  
  //Output features size(Output)
  const int OUT_SIZE[3]={max_i(blocks[0]-2,0),max_i(blocks[1]-2,0),27+4};
  const int O_DIM=OUT_SIZE[0]*OUT_SIZE[1];
  const int DIM_N =9*BLOCK_SQ;
  
  //Visible range (eliminate border blocks)
  const int visible[2]={blocks[0]*sbin,blocks[1]*sbin};
  const int vis_R[2] ={visible[0]-1,visible[1]-1};
  const int BLOCK_SQ2 = vis_R[0]*vis_R[1];
  const int vp0=dims[0]-2;
  const int vp1=dims[1]-2;
  const int SQUARE =dims[0]*dims[1];
  const FLOAT SBIN = FLOAT(sbin);
  
  //HOG Histgram and Norm
  FLOAT *HHist = (FLOAT*)calloc(BLOCK_SQ*18,sizeof(FLOAT)); // HOG histgram
  FLOAT *Norm = (FLOAT*)calloc(BLOCK_SQ,sizeof(FLOAT));     // Norm
  int X;int Y,A,B;
  
  int BBQ =2* visible[0] * visible[1];
  FLOAT *hozonn=(FLOAT*)calloc(BBQ,sizeof(FLOAT));
  int *locate=(int*)calloc(BBQ/2,sizeof(int));
  int *locate2=(int*)calloc(BLOCK_SQ ,sizeof(int));
  
  int iii;
  for (iii=0;iii<BBQ;iii++){
    *(hozonn+iii)=0;
  }
  
  //feature(Output)
  FLOAT *feat=(FLOAT*)calloc(OUT_SIZE[0]*OUT_SIZE[1]*OUT_SIZE[2],sizeof(FLOAT));
  
  //calculate HOG histgram
  for (X=1;(X+1)<blocks[1];X++)
    {
      for(Y=1;(Y+1)<blocks[0];Y++)
        {
          int a1 = X-1; 
          int a = (X-1) * sbin - sbin/2;
          int aa1 = X+2;
          int aa = (X+2) * sbin + sbin/2;
          if (X == 1){a = 1;aa1 = 0;}
          if ((X+2)==blocks[1]){aa = vis_R[1]; aa1 =blocks[1];}
          int b1 = Y-1;
          int b = (Y-1) * sbin - sbin/2;
          int bb1 = Y+2;
          int bb = (Y+2) * sbin + sbin/2;
          if (Y == 1){b = 1;bb1 = 0;}
          if ((Y+2)==blocks[0]){bb =vis_R[0]; bb1 =blocks[0];}
          FLOAT v;int best_o;
          
          for(int x=a;x<aa;x++)
            {
              //parameters for interpolation
              FLOAT xp=((FLOAT)x+0.5)/SBIN-0.5;
              int ixp=(int)floor(xp);
              int ixpp=ixp+1;
              int ixp_b  = ixp * blocks[0];
              int ixpp_b = ixp_b + blocks[0];
              FLOAT vx0=xp-(FLOAT)ixp;	
              FLOAT vx1=1.0-vx0;
              bool flag1=true,flag2=true,flagX=true;
              if(ixp<0) {flag1=false;flagX=false;}
              if(ixpp>=blocks[1]) {flag2=false;flagX=false;}
              int YC=min_i(x,vp1)*dims[0];
              FLOAT *SRC_YC = SRC+YC;
              
              for(int y=b;y<bb;y++)
                {
                  
                  if (*(locate+x*(vis_R[0])+y) == 1){break;}
                  
                  //first color channel
                  FLOAT *s=SRC_YC+min_i(y,vp0);
                  FLOAT dy=*(s+1)-*(s-1);
                  FLOAT dx=*(s+dims[0])-*(s-dims[0]);
                  FLOAT v=dx*dx+dy*dy;
                  
                  //second color channel
                  s+=SQUARE;
                  FLOAT dy2=*(s+1)-*(s-1);
                  FLOAT dx2=*(s+dims[0])-*(s-dims[0]);
                  FLOAT v2=dx2*dx2+dy2*dy2;
                  
                  //third color channel
                  s+=SQUARE;
                  FLOAT dy3=*(s+1)-*(s-1);
                  FLOAT dx3=*(s+dims[0])-*(s-dims[0]);
                  FLOAT v3=dx3*dx3+dy3*dy3;
                  
                  //pick channel with strongest gradient
                  if(v2>v){v=v2;dx=dx2;dy=dy2;}
                  if(v3>v){v=v3;dx=dx3;dy=dy3;}
                  
                  FLOAT best_dot=0.0;
                  int best_o=0;
                  
                  //snap to one of 18 orientations
                  for(int o=0;o<9;o++)
                    {
                      FLOAT dot=Hcos[o]*dx+Hsin[o]*dy;
                      if(dot>best_dot)		{best_dot=dot;best_o=o;}
                      else if (-dot>best_dot)	{best_dot=-dot;best_o=o+9;}
                    }
                  
                  *(hozonn+x*(vis_R[0])+y) = v;
                  *(hozonn+x*(vis_R[0])+y+BLOCK_SQ2) = best_o;
                  *(locate+x*(vis_R[0])+y) = 1;
                  
                  
                  //Add to 4 histgrams around pixel using linear interpolation
                  FLOAT yp=((FLOAT)y+0.5)/SBIN-0.5;
                  int iyp=(int)floor(yp);
                  int iypp=iyp+1;
                  FLOAT vy0=yp-(FLOAT)iyp;
                  FLOAT vy1=1.0-vy0;
                  v=sqrt(v);
                  int ODim=best_o*BLOCK_SQ;
                  FLOAT *Htemp = HHist+ODim;
                  FLOAT vx1Xv =vx1*v;
                  FLOAT vx0Xv = vx0*v;
                  
                  if(flagX)
                    {
                      if(iyp>=0)
                        {
                          *(Htemp+ ixp_b+iyp)+=vy1*vx1Xv;
                          *(Htemp+ ixpp_b+iyp)+=vy1*vx0Xv;
                        }
                      if (iypp<blocks[0])
                        {
                          *(Htemp+ ixp_b+iypp)+=vy0*vx1Xv;
                          *(Htemp+ ixpp_b+iypp)+=vy0*vx0Xv;
                        }
                    }
                  else if(flag1)
                    {
                      if (iyp>=0) *(Htemp+ixp_b+iyp)+=vy1*vx1Xv;
                      if (iypp<blocks[0]) *(Htemp+ixp_b+iypp)+=vy0*vx1Xv;
                    }
                  else if(flag2)
                    {
                      if(iyp>=0) *(Htemp+ixpp_b+iyp)+=vy1*vx0Xv;
                      if(iypp<blocks[0]) *(Htemp+ixpp_b+iypp)+=vy0*vx0Xv;
                    }
                }
            }
          /*}
			}*/
          
          
          //compute energy in each block by summing over orientations
          FLOAT *ttt;
          for(A= a1;A<aa1;A++)
            {
              for(B=b1;B<bb1;B++)
                {	
                  //printf("A:%d,B:%d height:%d,sbin:%d\n",A,B,height,sbin);
                  
                  for(int kk=0;kk<9;kk++)
                    {
                      if (*(locate2+A*blocks[0]+B) == 1){break;}
                      ttt = Norm+blocks[0]*A+B;
                      FLOAT *src1=HHist+blocks[0]*A+B+kk*BLOCK_SQ;
                      FLOAT *src2=src1+DIM_N;
                      FLOAT sss=*src1+*src2;
                      *ttt+=sss*sss;
                    }
                  *(locate2+A*blocks[0]+B) = 1;
                }
              
            }
        }
    }
  /*printf("HHist%f\n",*(HHist));*/
  
  /*FLOAT *ttt=Norm+blocks[0]*X+Y;
	for(X = 0;X<blocks[1];X++)
    {
    for(Y = 0;Y<blocks[0];Y++)
    {   
    for(int kk=0;kk<9;kk++)
    {
    FLOAT *ttt=Norm+blocks[0]*X+Y;
    FLOAT *src1=HHist+blocks[0]*X+Y+kk*BLOCK_SQ;
    FLOAT *src2=src1+DIM_N;
    
    FLOAT sss=*src1+*src2;
    *ttt+=sss*sss;
    }
    ttt++;
    }
    }*/
  
  //compute features
  FLOAT n1,n2,n3,n4;
  for(int X=0;X<OUT_SIZE[1];X++)
    {
      for(int Y=0;Y<OUT_SIZE[0];Y++)
        {
          FLOAT *dst = feat+X*OUT_SIZE[0]+Y;
          FLOAT *pt = Norm+(X+1)*blocks[0]+(Y+1);
          n4 = 1.0/sqrt(*pt+*(pt-1)+*(pt-blocks[0])+*(pt-blocks[0]-1)+eps);
          n2 = 1.0/sqrt(*pt+*(pt-1)+*(pt+blocks[0])+*(pt+blocks[0]-1)+eps);
          n3 = 1.0/sqrt(*pt+*(pt+1)+*(pt-blocks[0])+*(pt+blocks[0]+1)+eps);
          n1 = 1.0/sqrt(*pt+*(pt+1)+*(pt+blocks[0])+*(pt+blocks[0]+1)+eps);
          
          
          
          //features for each orientations
          FLOAT t1=0,t2=0,t3=0,t4=0;
          
          //contrast-sensitive features(18)
          FLOAT *src=HHist+(X+1)*blocks[0]+Y+1;
          for(int kk=0;kk<18;kk++)
            {
              FLOAT h1=min_2(*src*n1);
              FLOAT h2=min_2(*src*n2);
              FLOAT h3=min_2(*src*n3);
              FLOAT h4=min_2(*src*n4);
              *dst=0.5*(h1+h2+h3+h4);
              t1+=h1;
              t2+=h2;
              t3+=h3;
              t4+=h4;
              dst+=O_DIM;
              src+=BLOCK_SQ;
            }
          
          //contrast-insensitive features(9)
          src=HHist+(X+1)*blocks[0]+Y+1;
          for(int kk=0;kk<9;kk++)
            {
              FLOAT sum = *src+*(src+DIM_N);
              FLOAT h1=min_2(sum*n1);
              FLOAT h2=min_2(sum*n2);
              FLOAT h3=min_2(sum*n3);
              FLOAT h4=min_2(sum*n4);
              *dst=0.5*(h1+h2+h3+h4);
              dst+=O_DIM;
              src+=BLOCK_SQ;
            }
          
          //texture gradient
          *dst=0.2357*t1;
          dst+=O_DIM;
          *dst=0.2357*t2;
          dst+=O_DIM;
          *dst=0.2357*t3;
          dst+=O_DIM;
          *dst=0.2357*t4;
        }
    }
  
  
  //Release
  s_free(HHist);
  s_free(Norm);
  s_free(hozonn);
  s_free(locate);
  s_free(locate2);
  
  //size of feature(output)
  *FTSIZE=OUT_SIZE[0];
  *(FTSIZE+1)=OUT_SIZE[1];
  
  //	printf("feat%f\n",*(feat));
  return(feat);
  
}
